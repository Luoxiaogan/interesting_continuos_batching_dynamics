# 第四阶段：特征方程与极限方程的根可视化

## 目标

新增一张图 `roots_analysis.png`，展示：
1. **特征方程** $F(\lambda) = 0$ 的所有根相对于单位圆盘
2. **极限方程** $(1-\lambda)A(\lambda) = 0$ 的所有根相对于单位圆盘

---

## 理论背景（来自 `multiple_discrete.tex`）

### 极限方程 $(1-\lambda)A(\lambda) = 0$

$$
(1-\lambda)A(\lambda) = -\lambda^{l_B} + p\lambda^{l_B-l_A} + q = 0
$$

其中 $p = \frac{\lambda_A}{\lambda_A + \lambda_B}$, $q = 1 - p$

**性质**（Theorem 1）：
- 所有根满足 $|\lambda| \leq 1$
- $|\lambda| = 1$ 当且仅当 $\lambda^g = 1$，其中 $g = \gcd(l_A, l_B)$
- 若 $\gcd(l_A, l_B) = 1$，则 $A(\lambda)$ 的所有根满足 $|\lambda| < 1$

### 特征方程 $F(\lambda) = 0$

$$
F(\lambda) = (l_0+l_B)A(\lambda) - \lambda A'(\lambda)
$$

等价形式：
$$
F(\lambda) = (l_0+1)\lambda^{l_B-1} + \sum_{m=1}^{l_A-1}(l_0+m+1)\lambda^{l_B-1-m} + (1-p)\sum_{m=l_A}^{l_B-1}(l_0+m+1)\lambda^{l_B-1-m}
$$

**性质**（Theorem 2 & 3）：
- 若 $\gcd(l_A, l_B) > 1$：对于足够大的 $l_0$，有 $g-1$ 个根满足 $|\lambda| > 1$（不稳定）
- 若 $\gcd(l_A, l_B) = 1$：对于足够大的 $l_0$，所有根满足 $|\lambda| < 1$（稳定）

---

## 可视化设计

### 单子图布局

一个复平面图，包含：
1. **单位圆**：灰色虚线圆
2. **极限方程根**：
   - $|\lambda| = 1$：蓝色圆形 marker
   - $|\lambda| < 1$：绿色圆形 marker
3. **特征方程根**：
   - $|\lambda| > 1$：红色 × marker（不稳定根）
   - $|\lambda| \leq 1$：橙色 × marker

### 图例和标注
- 标题：包含 $l_0, l_A, l_B, \gcd$ 信息
- 显示稳定性判断：$\gcd(l_A, l_B) = ?$

---

## 实现步骤

### Step 1: 在 `metrics.py` 新增根计算函数

```python
def compute_characteristic_roots(l0: int, l_A: int, l_B: int,
                                  lambda_A: float, lambda_B: float) -> np.ndarray:
    """
    计算特征方程 F(λ) = 0 的所有根。
    F(λ) = (l_0+1)λ^{l_B-1} + Σ(l_0+m+1)λ^{l_B-1-m} + (1-p)Σ(...)
    """
    p = lambda_A / (lambda_A + lambda_B)
    # 构建多项式系数
    coeffs = [0.0] * l_B  # 度数为 l_B-1
    # ... 填充系数
    return np.roots(coeffs)

def compute_limit_roots(l_A: int, l_B: int,
                        lambda_A: float, lambda_B: float) -> np.ndarray:
    """
    计算极限方程 (1-λ)A(λ) = -λ^{l_B} + p·λ^{l_B-l_A} + q = 0 的所有根。
    """
    p = lambda_A / (lambda_A + lambda_B)
    q = 1 - p
    # 多项式: -λ^{l_B} + p·λ^{l_B-l_A} + q = 0
    coeffs = [0.0] * (l_B + 1)
    coeffs[0] = -1.0           # λ^{l_B} 系数
    coeffs[l_A] = p            # λ^{l_B-l_A} 系数
    coeffs[l_B] = q            # 常数项
    return np.roots(coeffs)
```

### Step 2: 在 `visualize_coupling.py` 新增可视化函数

```python
def plot_roots_analysis(l0: int, l_A: int, l_B: int,
                        lambda_A: float, lambda_B: float,
                        output_path: Optional[Path] = None,
                        title: str = "Roots Analysis"):
    """
    绘制特征方程和极限方程的根在复平面上的位置。
    """
    from metrics import compute_characteristic_roots, compute_limit_roots
    import math

    char_roots = compute_characteristic_roots(l0, l_A, l_B, lambda_A, lambda_B)
    limit_roots = compute_limit_roots(l_A, l_B, lambda_A, lambda_B)
    gcd = math.gcd(l_A, l_B)

    fig, ax = plt.subplots(figsize=(10, 10))

    # 绘制单位圆
    theta = np.linspace(0, 2*np.pi, 100)
    ax.plot(np.cos(theta), np.sin(theta), 'gray', linestyle='--', linewidth=1.5, label='Unit Circle')

    # 绘制极限方程根
    for root in limit_roots:
        norm = abs(root)
        if abs(norm - 1.0) < 1e-6:
            ax.scatter(root.real, root.imag, c='blue', s=100, marker='o', zorder=5)
        else:
            ax.scatter(root.real, root.imag, c='green', s=100, marker='o', zorder=5)

    # 绘制特征方程根
    for root in char_roots:
        norm = abs(root)
        if norm > 1.0 + 1e-6:
            ax.scatter(root.real, root.imag, c='red', s=120, marker='x', linewidths=2, zorder=6)
        else:
            ax.scatter(root.real, root.imag, c='orange', s=120, marker='x', linewidths=2, zorder=6)

    # 设置标题和标签
    ax.set_title(f'{title}\nl₀={l0}, l_A={l_A}, l_B={l_B}, gcd={gcd}')
    ax.set_xlabel('Real')
    ax.set_ylabel('Imaginary')
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.3)
    ax.legend()

    plt.tight_layout()
    if output_path:
        plt.savefig(output_path, dpi=150)
    plt.close()
```

### Step 3: 在 `run_coupling_experiment.py` 调用新可视化

在 `main()` 函数的可视化部分添加：

```python
from visualize_coupling import plot_roots_analysis

plot_roots_analysis(
    l0=config['l0'], l_A=config['l_A'], l_B=config['l_B'],
    lambda_A=config['lambda_A'], lambda_B=config['lambda_B'],
    output_path=output_dir / 'roots_analysis.png',
    title="Characteristic & Limit Equation Roots"
)
```

---

## 关键文件修改清单

| 文件 | 修改内容 |
|------|---------|
| `metrics.py` | 新增 `compute_characteristic_roots`, `compute_limit_roots` |
| `visualize_coupling.py` | 新增 `plot_roots_analysis` |
| `run_coupling_experiment.py` | 添加调用 `plot_roots_analysis` |

---

## 输出文件

```
outputs/YYYYMMDD_HHMMSS/
├── comparison.png
├── eviction_detail.png
├── G_comparison.png
├── G_decomposed.png
├── roots_analysis.png      # [新增] 特征方程与极限方程根
├── trajectory.csv
└── config.json
```

---

## 多项式系数构建详解

### 极限方程 $(1-\lambda)A(\lambda) = -\lambda^{l_B} + p\lambda^{l_B-l_A} + q = 0$

多项式系数数组（从高次到低次）：
```python
# 度数为 l_B
coeffs = [0.0] * (l_B + 1)
coeffs[0] = -1.0                    # λ^{l_B}
coeffs[l_A] = p                     # λ^{l_B - l_A}
coeffs[l_B] = q                     # λ^0 (常数项)
```

### 特征方程 $F(\lambda)$

$$F(\lambda) = (l_0+1)\lambda^{l_B-1} + \sum_{m=1}^{l_A-1}(l_0+m+1)\lambda^{l_B-1-m} + (1-p)\sum_{m=l_A}^{l_B-1}(l_0+m+1)\lambda^{l_B-1-m}$$

多项式系数数组（从高次到低次）：
```python
# 度数为 l_B - 1
coeffs = [0.0] * l_B
coeffs[0] = l0 + 1                           # λ^{l_B-1}
for m in range(1, l_A):
    coeffs[m] = l0 + m + 1                   # λ^{l_B-1-m}
for m in range(l_A, l_B):
    coeffs[m] = (1 - p) * (l0 + m + 1)       # λ^{l_B-1-m}
```

---

## 预期结果

当前配置 $l_A=6, l_B=23$：
- $\gcd(6, 23) = 1$（互质）
- 极限方程根：全部在单位圆内或单位圆上（$\lambda=1$）
- 特征方程根：对于足够大的 $l_0$，全部在单位圆内（稳定）

---

## 注意事项

1. **numpy.roots** 输入系数顺序：从最高次到最低次
2. **浮点精度**：判断 $|\lambda| = 1$ 时使用容差 `1e-6`
3. **复数处理**：根可能是复数，需要同时绘制实部和虚部
