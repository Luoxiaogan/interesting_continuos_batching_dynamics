# Coupling Experiments 实现细节

本文档详细说明 `coupling_experiments` 模块的实现细节，包括设计思路、核心算法和代码结构。

---

## 目录

1. [项目背景](#1-项目背景)
2. [核心概念](#2-核心概念)
3. [文件结构](#3-文件结构)
4. [模块详解](#4-模块详解)
5. [G Metrics 详解](#5-g-metrics-详解)
6. [数据流](#6-数据流)
7. [相关文档](#7-相关文档)

---

## 1. 项目背景

### 1.1 研究目标

对比 2-types coprime overloaded LLM serving 系统的两种演化轨迹：

| 模型 | 特点 | 对应代码 |
|------|------|---------|
| **Theory** | 无 eviction，允许负数 admission | `theory_simulator.py` |
| **Simulation** | 有 eviction，强制非负约束 | `multi_type_simulator.py` |

### 1.2 预期行为："Diverge then Converge"

1. **Diverge（分叉）**：当 Theory 出现负 admission 时，Simulation 通过 eviction 处理
2. **Converge（收敛）**：两者最终收敛到相同的 fluid equilibrium（当 gcd(l_A, l_B) = 1）

### 1.3 理论基础

- **Coprime 稳定性条件**：当 gcd(l_A, l_B) = 1 时，系统稳定
- **Token Balance**：`completion_tokens - increment_tokens = admission_tokens`
- **参考论文**：`tex_docs/multiple_discrete.tex`

---

## 2. 核心概念

### 2.1 状态表示

系统状态是一个 2D 结构：`state[stage][type]`

**示例**：l₀=2, l_A=2, l_B=3

```
        Type A    Type B
Stage 0:  X[0][A]   X[0][B]    ← 两种 type 都有
Stage 1:  X[1][A]   X[1][B]    ← A 最后一步
Stage 2:    -       X[2][B]    ← 只有 B（A 已完成）
```

### 2.2 Stage vs Length

| 概念 | 定义 | 使用场景 |
|------|------|---------|
| **Stage** | 0, 1, ..., max(l_A, l_B)-1 | Theory Simulator |
| **Length** | l₀ + stage | Simulation |

转换关系：`length = l₀ + stage`

### 2.3 Token Balance 方程

每个 batch：
```
completion_tokens = (l₀ + l_A) × completing_A + (l₀ + l_B) × completing_B
increment_tokens = non_completing_requests × 1
available_tokens = completion_tokens - increment_tokens
admission = available_tokens / (l₀ + 1)
```

---

## 3. 文件结构

```
coupling_experiments/
├── config.json                    # 实验参数配置
├── run_coupling_experiment.py     # 主实验脚本
├── theory_simulator.py            # Theory 模拟器（无约束）
├── metrics.py                     # G metrics 计算函数
├── visualize_coupling.py          # 可视化函数
├── documents/                     # 文档目录
│   ├── 实现细节.md                # 本文档
│   ├── 使用说明.md                # 使用说明
│   ├── 第一阶段_实现的思考.md     # 第一阶段设计思考
│   ├── 第一阶段_PLAN.md           # 第一阶段计划
│   ├── 第二阶段_跟踪_max_minus_min.md  # 第二阶段：G metric
│   ├── 第三阶段_测试各种版本的G.md     # 第三阶段：G 变体
│   └── 第四阶段_特征方程的根的可视化.md # 第四阶段：根分析
└── outputs/                       # 实验输出目录
    └── YYYYMMDD_HHMMSS/
        ├── config.json            # 实验配置快照
        ├── trajectory.csv         # 轨迹数据
        ├── comparison.png         # Admission/Eviction 对比图
        ├── eviction_detail.png    # Eviction 分布图
        ├── G_comparison.png       # G (combined) 对比图
        ├── G_decomposed.png       # G 分解图（2×4）
        └── roots_analysis.png     # 特征方程与极限方程根
```

---

## 4. 模块详解

### 4.1 `theory_simulator.py` - Theory 模拟器

**核心类**：`TheorySimulator`

**关键特性**：
- 允许负数 admission（当 completion < increment 时）
- 状态可以为负数（无非负约束）
- 严格遵循 token balance 方程

**核心方法 `update()`**：

```python
def update(self):
    # 1. 计算 completion_tokens
    completion_A = self.X[self.l_A - 1][0]  # Type A 完成
    completion_B = self.X[self.l_B - 1][1]  # Type B 完成
    completion_tokens = (l0 + l_A) * completion_A + (l0 + l_B) * completion_B

    # 2. 计算 increment_tokens（非完成请求各增加 1 token）
    increment_tokens = sum(non_completing_requests)

    # 3. 计算 admission（可负）
    available_tokens = completion_tokens - increment_tokens
    total_admission = available_tokens / (l0 + 1)
    admission_A = total_admission * p  # p = λ_A / (λ_A + λ_B)
    admission_B = total_admission * (1 - p)

    # 4. 状态推进
    # stage i → stage i+1, 新 admission 进入 stage 0
```

**状态格式**：`state[stage][type_idx]`，stage ∈ [0, max_stage]

### 4.2 `metrics.py` - G Metrics

**函数列表**：

| 函数 | 说明 |
|------|------|
| `compute_G` | 全局 max - min（两种 type 合并） |
| `compute_G_weighted` | 加权版本：max(x/w) - min(x/w)，w = l₀ + stage + 1 |
| `compute_G_A` | 只看 Type A 的 max - min |
| `compute_G_B` | 只看 Type B 的 max - min |
| `compute_G_merge` | 合并 A+B 并补偿（均衡时趋近 0） |
| `compute_G_merged_raw` | 合并 A+B 无补偿（均衡时非零） |
| `compute_characteristic_roots` | 计算特征方程 F(λ)=0 的根 |
| `compute_limit_roots` | 计算极限方程 (1-λ)A(λ)=0 的根 |

**state_format 参数**：
- `'stage'`：Theory 格式，`state[stage][type]`
- `'length'`：Simulation 格式，`state[length][type]`

### 4.3 `visualize_coupling.py` - 可视化

**函数列表**：

| 函数 | 输出文件 | 说明 |
|------|---------|------|
| `plot_comparison` | `comparison.png` | Admission/Eviction 对比 |
| `plot_eviction_detail` | `eviction_detail.png` | Eviction 按 stage 分布 |
| `plot_G_comparison` | `G_comparison.png` | G (combined) 对比 |
| `plot_G_decomposed` | `G_decomposed.png` | 2×4 G 分解图 |
| `plot_roots_analysis` | `roots_analysis.png` | 特征方程与极限方程根 |

**G_decomposed 布局**：

| | 第1列 | 第2列 | 第3列 | 第4列 |
|---|-------|-------|-------|-------|
| **上排** | G_A | G_B | G_merge | G_merged_raw |
| **下排** | Δ G_A | Δ G_B | Δ G_merge | Δ G_merged_raw |

- 上排：Theory（蓝）vs Simulation（绿）
- 下排：差值（紫），负值点用红色标注

### 4.4 `run_coupling_experiment.py` - 主脚本

**执行流程**：

```
1. 读取 config.json
2. 初始化 Theory Simulator 和 Simulation
3. 设置相同的初始条件
4. 并行运行两个模拟器
5. 提取每个 batch 的数据：
   - admission（Theory/Simulation）
   - eviction（Simulation）
   - G metrics（多种）
6. 保存 trajectory.csv 和 config.json
7. 生成可视化图表
```

---

## 5. G Metrics 详解

### 5.1 设计动机

G metric 来源于 `single_discrete.tex` 中的能量泛函思想（第 639 行）：

$$G_i = \max_{t}\{x_i^{(t)}/w_t\} - \min_{t}\{x_i^{(t)}/w_t\}$$

用于证明系统的 collapse 行为：G 单调不减，直到触发更深层 eviction。

### 5.2 简化版本（当前实现）

当前实现不除以权重，直接计算 max - min：

$$G = \max(\text{state values}) - \min(\text{state values})$$

### 5.3 G_merge 补偿逻辑

**问题**：当 l_A ≠ l_B 时，某些 stage 只有一种 type，直接合并会导致数值偏小。

**解决方案**：补偿缺失 type 的流量。

**示例**：l_A=2, l_B=3, λ_A=λ_B=1

```
Stage 0: merged = A + B
Stage 1: merged = A + B
Stage 2: merged = B × (λ_A + λ_B) / λ_B = B × 2  ← 补偿
```

**通用公式**：

```python
if l_A < l_B:
    # Stage l_A 到 l_B-1 只有 B
    补偿系数 = (λ_A + λ_B) / λ_B
elif l_A > l_B:
    # Stage l_B 到 l_A-1 只有 A
    补偿系数 = (λ_A + λ_B) / λ_A
```

### 5.4 G_merge vs G_merged_raw

| Metric | 补偿 | 均衡时行为 |
|--------|------|-----------|
| `G_merge` | 有 | 趋近 0 |
| `G_merged_raw` | 无 | 趋近非零常数 |

---

## 6. 数据流

```
config.json
    │
    ▼
run_coupling_experiment.py
    │
    ├── TheorySimulator.run(steps)
    │   └── get_state_history() → List[{batch, state}]
    │
    ├── MultiTypeLLMSimulator.run(steps)
    │   └── get_history() → {X_prime, admissions, evictions}
    │
    └── 处理每个 batch:
        │
        ├── compute_G(theory_state, format='stage')
        ├── compute_G(sim_state, format='length')
        ├── compute_G_A, compute_G_B, ...
        │
        └── trajectory.append(row)
            │
            ▼
        trajectory.csv + 可视化图表
```

---

## 7. 相关文档

详细的设计思考和演化过程请参考以下文档：

1. **[第一阶段_实现的思考.md](第一阶段_实现的思考.md)**
   - Theory vs Simulation 的核心差异分析
   - Token balance 方程推导
   - 初始条件设计

2. **[第一阶段_PLAN.md](第一阶段_PLAN.md)**
   - 第一阶段实现计划
   - 文件结构设计
   - 输出格式定义

3. **[第二阶段_跟踪_max_minus_min.md](第二阶段_跟踪_max_minus_min.md)**
   - G metric 的引入背景
   - 简化版 G 的定义
   - 实验结果分析

4. **[第三阶段_测试各种版本的G.md](第三阶段_测试各种版本的G.md)**
   - G_A, G_B, G_merge, G_merged_raw 的设计
   - 补偿逻辑详解
   - 2×4 可视化布局

5. **[第四阶段_特征方程的根的可视化.md](第四阶段_特征方程的根的可视化.md)**
   - 特征方程 F(λ)=0 与极限方程 (1-λ)A(λ)=0
   - 根的稳定性分析（单位圆盘）
   - gcd 与系统稳定性的关系

---

**文档版本**：v1.1
**创建日期**：2026-01-04
**最后更新**：2026-01-04
