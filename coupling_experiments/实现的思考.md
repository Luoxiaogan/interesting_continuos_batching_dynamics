# Coupling Experiments: Theory vs Simulation 对比实验

## 1. 背景与目标

### 1.1 研究问题
对于 2-types 的 overloaded LLM serving 系统（coprime 情况），对比：
- **Theory trajectory**：无 eviction，允许负数请求
- **Simulation trajectory**：有 eviction，强制非负约束

两者从相同初始点出发，经历 "diverge then converge" 的过程，最终收敛到同一个 fluid equilibrium。

### 1.2 理论基础
- 理论文档：`coupling_experiments/tex_docs/multiple_discrete.tex`
- 核心模拟器：`new_project_for_multi_type/multi_type_simulator.py`

## 2. Theory vs Code 的对应关系

### 2.1 Match 的部分

| 方面 | Theory (tex) | Code | 说明 |
|------|--------------|------|------|
| **Memory Bound** | 总 tokens = B（常数） | `assert Z == B` | 完全一致 |
| **Admission 比例** | $p = \lambda_A / (\lambda_A + \lambda_B)$ | 按 `λ_k` 比例分配 | 完全一致 |
| **Coprime 稳定性** | $\gcd(l_A, l_B) = 1 \Rightarrow$ 稳定 | 同样适用 | 完全一致 |
| **Token 平衡** | completion - increment = admission | `available_tokens = B - token_used` | 完全一致 |
| **Fluid 模型** | 确定性（无随机） | 确定性 | 完全一致 |

### 2.2 不 Match 的部分

| 方面 | Theory | Code | 影响 |
|------|--------|------|------|
| **Eviction** | 不考虑 | 有实现（按 decode priority） | Theory 可能出现负数 |
| **非负约束** | 不考虑（允许负数） | 强制非负 | 当 Theory 为负时 diverge |
| **状态表示** | $X^{(stage)}_t$ 总数 | `X[length][type]` 分开 | 可聚合等价 |

### 2.3 关键发现：Eviction 的比例

代码中的 eviction 是按**当前请求数量比例**进行的（第255-267行）：
```python
eviction_ratio = 1 - (available_tokens / total_needed)
retained_requests = current_requests * (1 - eviction_ratio)
```

**重要结论**：如果状态已经按 $p:(1-p)$ 比例，则 eviction 也等价于按 arrival rate 比例。

## 3. 实验设计

### 3.1 关键观察

> "因为 admission 按照比例, eviction 也按照比例; 所以即使初始点有可能会不按照比例, 但是经过 max(l_A, l_B) 之后, 肯定整个都按照比例了"

**推论**：如果初始状态也按比例，那么整个过程比例恒定，Theory 的方案 A（只追踪总数）和方案 B（分开追踪）等价。

### 3.2 Theory Trajectory 实现

**选择方案 B：精确追踪**
- 追踪 `X[stage][type]`（与 simulation 一致）
- 无 eviction，允许负数
- 按 token 平衡计算 admission（可能为负）

### 3.3 初始条件设计

**方案：只有 stage 0 有请求**
```
Type A: X[stage=0][A] = p * N
Type B: X[stage=0][B] = (1-p) * N
其他 stages: 全部为 0
```

其中 $N = B / (l_0 + 1)$，使得总 tokens = B。

**为什么会触发 eviction？**
- 第1步：没有完成（stage l_A-1 和 l_B-1 都是空的）
- 所有 stage 0 的请求移动到 stage 1，增加 N tokens
- 需要 evict N tokens 来维持 B 约束
- **Theory**：admission = -N（负数）
- **Simulation**：eviction = N

**优点**：
1. 按比例 ✅
2. 总 tokens = B ✅
3. 一定触发 eviction ✅
4. 简单易理解 ✅

### 3.4 关于"负 admission"与 eviction 的不等价性

**重要区别**：
- Theory 的"负 admission"等价于"只从 stage 0 移除请求"
- Simulation 的 eviction 可以发生在任何 stage（按 decode priority 从低到高）

**结论**：两条 trajectory 的差异不仅是"是否有 eviction"，还包括"eviction 发生在哪个 stage"。因此需要完整记录 eviction 的 stage 信息。

## 4. 可视化设计

### 4.1 图1：Admission/Eviction 对比
- **横轴**：batch index
- **纵轴**：请求数目
  - Theory admission：蓝线，可正可负
  - Simulation admission：绿线，≥ 0
  - Simulation eviction：红色负值（总数）

### 4.2 图2：Eviction Stage 分布
- **横轴**：batch index
- **纵轴**：stage
- 堆叠条形图或热力图，显示每个 batch 中各 stage 的 eviction 数量

## 5. 参数选择

### 5.1 建议参数
```python
config = {
    "l0": 3,           # 小一些，让特征值 norm 接近 1
    "l_A": 2,          # decode length for Type A
    "l_B": 3,          # decode length for Type B, gcd(2,3)=1
    "B": 60,           # GPU capacity
    "lambda_A": 1.0,   # arrival rate A
    "lambda_B": 1.0,   # arrival rate B, p = 0.5
    "steps": 50,       # 模拟步数
}
```

### 5.2 特征值考虑
- $l_0$ 小 → 特征值 norm 更接近 1 → 收敛慢（便于观察）
- Coprime $(l_A, l_B)$ → 所有根 $|\lambda| < 1$ → 稳定收敛
- 需要先计算特征值验证参数合适性

### 5.3 初始条件计算
```python
p = lambda_A / (lambda_A + lambda_B)  # = 0.5
N = B / (l0 + 1)  # = 60 / 4 = 15

X_init[stage=0][A] = p * N = 7.5
X_init[stage=0][B] = (1-p) * N = 7.5
# 其他 stages = 0
```

## 6. 输出结构

```
coupling_experiments/outputs/YYYYMMDD_HHMMSS/
├── config.json          # 参数配置
├── trajectory.csv       # 每步的 admission/eviction
├── comparison.png       # 图1: Admission/Eviction 对比
└── eviction_detail.png  # 图2: Eviction Stage 分布
```

### trajectory.csv 格式
```csv
batch,theory_admission,sim_admission,sim_eviction_total,sim_eviction_stage0,sim_eviction_stage1,...
0,15.0,15.0,0,0,0,...
1,-7.5,0,7.5,7.5,0,...
...
```

## 7. 实现要点

### 7.1 Theory Trajectory 实现
1. 跟踪 `X[stage][type]`（可以是负数）
2. 每个 batch：
   - 计算完成释放的 tokens
   - 计算中间 stages 增加的 tokens
   - `available_tokens = completion - increment`（可能是负数）
   - `admission = available_tokens / (l_0+1)`，按比例分配（可能是负数）
   - 状态推进（允许负数）
3. 记录每步的 admission 总数

### 7.2 Simulation Trajectory
- 使用现有的 `MultiTypeLLMSimulator`
- 从同样的初始条件开始
- 记录 `batch_admissions` 和 `batch_evictions`（包括 stage 信息）

### 7.3 需要新写的代码
1. **特征值计算器**：验证参数选择
2. **Theory 模拟器**：无约束版本
3. **对比实验脚本**：运行两个 trajectory 并可视化
4. **可视化函数**：生成对比图

## 8. 预期结果

1. **初始阶段**：两条 trajectory 相同（没有 eviction）
2. **Diverge 阶段**：Theory 出现负数，Simulation 触发 eviction
3. **Converge 阶段**：两者都收敛到 fluid equilibrium
4. **最终状态**：两者相同（或非常接近）

## 9. 一些重要的我和claude code沟通的上下文细节:

### 轮次1:用户
```
1. 因为对于admission, 无论是theory还是模拟, 都是基于arrival rate比例的.
   1. 所以我觉得直接用这一步的admission的总数目就好了.
   2. 所以第一个图片是, 横轴是index(batch), 纵轴是数目
      1. 对于theory, 是这一步admission的总数目, 可以是正的也可以是负的
      2. 对于simulation, 
         1. 是这一步admission的数目(正的 or 0); 
         2. 或者是这一步eviction的数目(我记得eviction也是按照arrival rate比例, 所以eviction之后整个系统还是一样的比例)
            1. 但是我比较纠结的地方在于: admit 负数个req，只能解释在stage = 0的eviction吧。 例如stage更高的eviction，不能用这个等价
            2. 所以我建议你完整记录evcited的req之前所处的stage. 但是第一张图还是展示evicted reqs的总数(用负数值.)
2. 对于初始条件
   1. 你直接用两个type的对应的stage上的数目=1作为初始点.
3. Theory Trajectory 
   1. 写一个"无约束版"的模拟器
4. 展示 "diverge then converge"
   1. 横轴用batch index吧, 因为theory没考虑时间, 时间也不重要(in overloaded)
   2. 单图多线
5. 具体参数的选择, 先选择较小的参数，便于理解和可视化. 然后, 写一个多的程序, 求解coprime形式下的特征方程的特征值的norm, 大概希望最大的特征值norm更接近1但是比1小, 
这样系统收敛的慢一点点.
```

### 轮次1:claude code:
```
关于 Eviction 的关键问题

  你提出了一个很好的观点：

  "admit 负数个 req，只能解释在 stage=0 的 eviction 吧。例如 stage 更高的 eviction，不能用这个等价"

  这是对的。让我分析：

  Theory 中的"负 admission"

  - Theory 假设没有 eviction
  - 当 available_tokens < 0 时，admission 变成负数
  - 这等价于从 stage 0 移除请求

  Simulation 中的 eviction

  - Eviction 按 decode priority 从低到高（即从 stage 0 开始）
  - 但如果 stage 0 不够 evict，会继续 evict stage 1, 2, ...
  - 这与 theory 的"负 admission"不完全等价

  结论

  两条 trajectory 的差异不仅是：
  1. Theory 允许负数 vs Simulation 不允许
  2. 还包括：Theory 的"负 admission"只影响 stage 0，而 Simulation 的 eviction 可能影响多个 stage

  所以你说的对，需要完整记录 eviction 的 stage 信息。

  ---
  整理后的实现方案

  图1：Admission/Eviction 对比

  - 横轴：batch index
  - 纵轴：
    - Theory admission：蓝线，可正可负
    - Simulation admission：绿线，≥ 0
    - Simulation eviction：红色负值条形图（总数）

  图2（附加）：Eviction Stage 分布

  - 横轴：batch index
  - 纵轴：stage
  - 堆叠条形图或热力图，显示每个 batch 中各 stage 的 eviction 数量
  - 这可以展示 eviction 不仅发生在 stage 0

  ---
  Theory Trajectory 的实现

  问题

  tex 的递推公式假设每个 stage 的类型比例都是 p:(1-p)：
  $$X^{(l_A-1)}_t[A] = p \cdot X^{(l_A-1)}_t$$

  这在稳态成立，但在瞬态可能不成立。

  两种实现方式

  方式 A：严格按 tex（假设比例恒定）
  - 只追踪 $X^{(i)}_t$（总数），不分 type
  - 完成时按比例计算
  - 与 tex 分析完全一致

  方式 B：精确追踪（不假设比例恒定）
  - 追踪 $X[stage][type]$
  - 无 eviction，允许负数
  - 更精确，但与 tex 的简化分析略有不同

  建议：用方式 B，因为：
  1. 与 simulation 的状态表示一致，便于对比
  2. 只是去掉了 eviction 和非负约束
  3. 可以展示 theory 在哪些 (stage, type) 出现负数

  ---
  初始条件

  你说的"两个 type 的对应 stage 上的数目=1"：
  Type A: X[stage=0][A] = 1, X[stage=1][A] = 1, ..., X[stage=l_A-1][A] = 1
  Type B: X[stage=0][B] = 1, X[stage=1][B] = 1, ..., X[stage=l_B-1][B] = 1

  总 tokens（假设 $l_0=2, l_A=2, l_B=3$）：
  - Type A: $(3+4) \times 1 = 7$ tokens
  - Type B: $(3+4+5) \times 1 = 12$ tokens
  - 总计：19 tokens

  如果 $B = 50$，第一步需要 admit 填补差额。

  ---
  特征值计算

  根据 tex，极限形式的特征方程是：
  $$(1-\lambda)A(\lambda) = -\lambda^{l_B} + p\lambda^{l_B-l_A} + q = 0$$

  对于 coprime，所有根 $|\lambda| < 1$。我们要找 $\max|\lambda|$ 接近 1 的参数。

  候选参数（需要计算验证）：
  - $l_A=2, l_B=3$：gcd=1，$l_B - l_A = 1$（差小，可能收敛快）
  - $l_A=2, l_B=5$：gcd=1，$l_B - l_A = 3$（差大，可能收敛慢）
  - $l_A=3, l_B=5$：gcd=1
  - $l_A=4, l_B=7$：gcd=1

  ---
  还需要确认的问题

  1. Theory 实现方式：用方式 A（按 tex 简化）还是方式 B（精确追踪）？
    - 我倾向方式 B
  2. 可视化的纵轴单位：
    - Admission：请求数（与 theory 一致）
    - Eviction：请求数（负值）
    - 还是用 token 数？
  3. $l_0$ 的选择：
    - $l_0$ 大 → 特征值接近极限形式 $A(\lambda)$
    - $l_0$ 小 → 有限 $l_0$ 校正项影响大
    - 建议 $l_0 = 5$ 或更大
  4. Simulation 中 eviction 的比例：
    - 你说"eviction 也是按照 arrival rate 比例"
    - 让我确认一下代码...代码中的 eviction 是按 当前 stage 的实际请求数比例，不是 arrival rate 比例
    - 这是另一个潜在差异

  ---
  你对这些想法有什么反馈？特别是：
  1. Theory 用方式 A 还是方式 B？
  2. 纵轴用请求数还是 token 数？
  3. 需要我先写一个特征值计算的小程序来选参数吗？
```

### 轮次2:我:
```
1. 我赞同你的"整理后的实现方案".
2. Theory Trajectory 的实现
   1. 对于这两个实现方式, 我有如下的观察"因为admission按照比例, eviction也按照比例; 所以即使初始点有可能会不按照比例, 但是经过max(l_A,l_B)之后, 
肯定整个都按照比例了".
   2. 我建议: 方式 B：精确追踪
   3. 但是更改我之前说的初始点, 可以让初始点的也按照比例, 那么方案A和B应该是一样的? (请你思考)
3. 初始条件: 针对2-3思考我修改之后的初始条件.
4. 你应该维护一个config来注册参数, 然后每次实验在`coupling_experiments/outputs/`下面生成一个子文件夹(日期), 里面包含csv, png, config(复制)
5. 可视化的纵轴单位: 请求数目.
6. $l_0$ 的选择, l_0小一些, 这样root的norm更靠近圆盘外面.
7. Simulation 中 eviction 的比例: 你需要阅读multi type simulation的代码，在面对eviction的时候, 对于两个type，也是按照rate 
比例来分配eviction吗？(我记得是的,从而match上2-1.)
8. 仔细思考.
```

### 轮次2:claude code:
```
代码中的 Eviction 比例分析

  代码第255-267行显示：

  # 需要按比例驱逐
  eviction_ratio = 1 - (available_tokens / total_needed)
  for (type_idx, length), current_requests in request_counts.items():
      retained_requests = current_requests * (1 - eviction_ratio)

  Eviction 是按"当前请求数量比例"进行的，不是直接按 arrival rate。

  但是：如果当前状态已经按 $p:(1-p)$ 比例，那么：
  - Type A evicted = $p \times \text{totalevicted}$
  - Type B evicted = $(1-p) \times \text{totalevicted}$

  结论：与按 arrival rate 比例 evict 等价 ✅

  ---
  整理后的理解

  | 条件                      | 结果                  |
  |---------------------------|-----------------------|
  | 初始状态按 $p:(1-p)$ 比例 | 整个过程比例恒定      |
  | Admission 按比例          | ✅ 代码实现           |
  | Eviction 按比例           | ✅ 当状态按比例时等价 |
  | 方案 A = 方案 B           | ✅ 当初始状态按比例时 |

  ---
  初始条件的设计

  为了让初始状态按比例且能触发 eviction，我建议：

  方案：只有 stage 0 有请求

  Type A: X[stage=0][A] = p * N
  Type B: X[stage=0][B] = (1-p) * N
  其他 stages: 全部为 0

  其中 $N = B / (l_0 + 1)$，使得总 tokens = B。

  为什么会触发 eviction？
  - 第1步：没有完成（stage l_A-1 和 l_B-1 都是空的）
  - 所有 stage 0 的请求移动到 stage 1，增加 N tokens
  - 需要 evict N tokens 来维持 B 约束
  - Theory：admission = -N（负数）
  - Simulation：eviction = N（从 stage 0 或 1 evict）

  优点：
  1. 按比例 ✅
  2. 总 tokens = B ✅
  3. 一定触发 eviction ✅
  4. 简单易理解 ✅

  ---
  最终实验设计

  参数

  config = {
      "l0": 3,           # 小一些，让特征值接近 1
      "l_A": 2,          # decode length for Type A
      "l_B": 3,          # decode length for Type B, gcd(2,3)=1
      "B": 60,           # GPU capacity
      "lambda_A": 1.0,   # arrival rate A
      "lambda_B": 1.0,   # arrival rate B, p = 0.5
      "steps": 50,       # 模拟步数
  }

  初始条件

  p = lambda_A / (lambda_A + lambda_B)  # = 0.5
  N = B / (l0 + 1)  # = 60 / 4 = 15

  X_init[stage=0][A] = p * N = 7.5
  X_init[stage=0][B] = (1-p) * N = 7.5
  # 其他 stages = 0

  输出目录结构

  coupling_experiments/outputs/20260104_HHMMSS/
  ├── config.json          # 参数配置
  ├── trajectory.csv       # 每步的 admission/eviction
  ├── comparison.png       # 图1: Admission/Eviction 对比
  └── eviction_detail.png  # 图2: Eviction Stage 分布

  trajectory.csv 格式

  batch,theory_admission,sim_admission,sim_eviction_total,sim_eviction_stage0,sim_eviction_stage1,...
  0,15.0,15.0,0,0,0,...
  1,-7.5,0,7.5,7.5,0,...
  ...

  ---
  还需要确认

  1. 特征值计算：需要先写一个小程序验证 $l_0=3, l_A=2, l_B=3$ 的特征值 norm 是否合适（接近 1 但 < 1）
  2. 参数微调：如果特征值太小（收敛太快），可以调整参数
```

---

**文档版本**：v1.0
**创建日期**：2026-01-04
**状态**：待实现