# 实现细节与踩坑记录

## 1. Memory 计算的统一

### 问题
模拟器中存在两种 memory 计算方式：
- `current_memory = Σ(l0+i) × X[i]`
- `active_memory = Σ(l0+i+1) × X[i]`

最初 eviction 判断用 `active_memory`，而 `update_config.py` 计算稳态用 `current_memory`，导致：
- 明明设置了 90% 负载，实际 memory 却超过 B
- 出现不应该发生的 eviction

### 解决
统一使用 `active_memory = Σ(l0+i+1) × X[i]`：
- eviction 判断：`active_memory <= B`
- 服务时间：`s = b0 + b1 × active_memory`
- 稳态计算：`γ = Σ(l0+i+1) = l1×(l0+1) + l1×(l1-1)/2`

## 2. Latency 计算的 FIFO 匹配错误

### 问题
初始 X0 的 job 没有 `admission_record`，但它们完成时会"消耗"新 admit 的 job 的 record，导致：
- FIFO 队列永久偏移
- 不同 s 值的 latency 出现 4+ 秒的差异（68 vs 72 sec）
- 这个差异不会被平均掉，因为是队列长度的常数偏移

### 解决
在 `__init__` 中为 X0 的 job 创建虚拟 `admission_record`：
```python
for i in range(l1):
    if X0[i] > 0:
        batches_until_completion = l1 - i
        virtual_admission_time = -batches_until_completion * estimated_service_time
        self.admission_records[负数batch_id] = {
            'admission_time': virtual_admission_time,
            'jobs_remaining': X0[i]
        }
```

修复后 latency ≈ 83.2 sec（= l1 × service_time），符合理论值。

## 3. Admission Upper Bound (大S) 的计算

### 两个稳态的区别
- **X* = target_ratio × B / γ**：目标负载（如 90%）下的稳态，用于设置初始状态 X0
- **S = B / γ**：满载（100%）下的稳态，用于设置 admission 上界

### 含义
S 是满载稳态下每个 stage 的 job 数。每次 admission 不超过 S，确保 memory 不超过 B。

## 4. Timeseries 图的横轴

### 问题
最初用 batch index 作横轴，但不同 s 值下：
- 同一 batch index 对应的时间 T 不同
- 无法公平比较

### 解决
改用时间 T (sec) 作为横轴。

## 5. 关键公式汇总

```
γ = l1 × (l0 + 1) + l1 × (l1 - 1) / 2    # memory 系数

# target_ratio 负载下的稳态（用于初始化）
M* = target_ratio × B
X* = M* / γ
s* = b0 + b1 × M*
λ* = M* / (γ × s*)

# 满载稳态（用于 admission 上界）
S = B / γ

# 理论 latency
latency = l1 × service_time
```
